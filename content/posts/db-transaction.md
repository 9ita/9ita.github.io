### 데이터베이스 트랜잭션에 관한 고찰

**데이터베이스 트랜잭션**은 하나의 작업을 논리적으로 묶어서 처리하는 단위입니다. 트랜잭션은 **ACID** 속성(Atomicity, Consistency, Isolation, Durability)을 따르며, 이 중 **Isolation(고립성)**은 여러 트랜잭션이 동시에 실행될 때 발생하는 **간섭**을 어떻게 제어할 것인지 결정하는 핵심 요소입니다.

트랜잭션에서 **SELECT(읽기)**, **UPDATE(수정)**, **INSERT(삽입)** 작업은 각기 다른 데이터 처리 작업을 수행하지만, 동시에 실행될 때 서로 간섭을 줄 수 있습니다. 이 간섭을 어떻게 제어하는가는 **트랜잭션 격리 수준**과 **데이터베이스 락**과 같은 메커니즘에 따라 달라집니다.

---

### 1. 트랜잭션 간섭(Interference)의 유형

데이터베이스 트랜잭션은 서로 간섭을 줄 수 있으며, 이로 인해 발생하는 문제는 일반적으로 다음과 같은 형태로 나타납니다:

1. **Dirty Read (더티 리드)**:
   - 한 트랜잭션이 다른 트랜잭션에서 **커밋되지 않은 데이터**를 읽는 상황입니다.
   - 예: 트랜잭션 A가 데이터를 수정했지만 아직 커밋하지 않은 상태에서, 트랜잭션 B가 그 데이터를 읽으면, 트랜잭션 A가 롤백할 경우 B는 잘못된 데이터를 사용하게 됩니다.

2. **Non-repeatable Read (반복되지 않는 읽기)**:
   - 한 트랜잭션이 동일한 데이터를 여러 번 읽는 동안, 다른 트랜잭션이 그 데이터를 수정하는 상황입니다.
   - 예: 트랜잭션 A가 데이터를 읽고, 트랜잭션 B가 그 데이터를 수정한 후 다시 트랜잭션 A가 읽으면 다른 값이 나옵니다.

3. **Phantom Read (팬텀 리드)**:
   - 한 트랜잭션이 특정 조건에 맞는 데이터를 읽는 동안, 다른 트랜잭션이 새로운 데이터를 **삽입하거나 삭제**하여, 같은 쿼리에서 다른 결과가 나오는 상황입니다.
   - 예: 트랜잭션 A가 `WHERE` 조건으로 특정 데이터를 조회한 후, 트랜잭션 B가 새로운 데이터를 삽입하여 트랜잭션 A가 다시 조회할 때 이전과 다른 결과가 나옵니다.

---

### 2. 트랜잭션 격리 수준 (Isolation Level)

SQL 표준에서는 **트랜잭션 격리 수준**을 통해 트랜잭션 간의 간섭을 제어합니다. 각 수준은 간섭의 정도를 결정하며, 상호작용하는 트랜잭션의 읽기/쓰기 작업에 따라 데이터베이스의 성능과 일관성에 영향을 미칩니다.

#### 트랜잭션 격리 수준의 종류

1. **Read Uncommitted** (가장 낮은 격리 수준)
   - 트랜잭션이 커밋되지 않은 데이터도 읽을 수 있습니다.
   - **Dirty Read** 가능.
   - SELECT가 UPDATE나 INSERT 작업에 간섭을 받을 수 있음.

2. **Read Committed** (기본 수준, 대부분의 DBMS의 기본값)
   - 커밋된 데이터만 읽을 수 있습니다.
   - **Dirty Read**는 발생하지 않지만, **Non-repeatable Read**가 발생할 수 있습니다.
   - 트랜잭션이 SELECT를 두 번 실행하면, 그 사이에 다른 트랜잭션이 데이터를 수정할 수 있습니다.

3. **Repeatable Read** (격리 수준이 더 높은 단계)
   - 트랜잭션 내에서 동일한 데이터를 여러 번 읽어도 항상 동일한 결과를 반환합니다.
   - **Non-repeatable Read**는 발생하지 않지만, **Phantom Read**는 발생할 수 있습니다.
   - UPDATE와 INSERT 작업은 SELECT 작업에 간섭을 줄 가능성이 적습니다.

4. **Serializable** (가장 높은 격리 수준)
   - 모든 트랜잭션이 서로 직렬화되며, 트랜잭션이 독립적으로 처리됩니다.
   - **Dirty Read**, **Non-repeatable Read**, **Phantom Read**가 모두 방지됩니다.
   - 성능이 떨어질 수 있으나, 트랜잭션 간의 간섭이 발생하지 않습니다.

#### 격리 수준이 간섭에 미치는 영향
- **Read Uncommitted**에서는 UPDATE 또는 INSERT가 SELECT 작업을 방해할 수 있으며, 아직 커밋되지 않은 데이터가 SELECT에 노출될 수 있습니다.
- **Read Committed** 이상에서는 커밋된 데이터만 노출되므로, SELECT가 UPDATE나 INSERT에 의한 간섭을 받지 않습니다. 다만 트랜잭션이 실행되는 동안 데이터가 변할 수 있어 반복되지 않는 읽기가 발생할 수 있습니다.
- **Repeatable Read**나 **Serializable** 수준에서는 간섭이 거의 발생하지 않으며, SELECT 작업은 트랜잭션이 끝날 때까지 동일한 데이터를 반환하도록 보장됩니다.

---

### 3. 테이블에서의 SELECT, UPDATE, INSERT의 상호작용

**SELECT, UPDATE, INSERT**가 서로 간섭을 주는지는 **데이터베이스 락킹 메커니즘**과 **트랜잭션 격리 수준**에 따라 달라집니다. 일반적으로, UPDATE와 INSERT는 **쓰기 작업**으로, SELECT는 **읽기 작업**으로 구분되며, 상호 간섭은 다음과 같은 방식으로 발생할 수 있습니다:

#### a. **SELECT와 UPDATE 간의 상호작용**
- **SELECT가 먼저 실행된 경우**: 트랜잭션 격리 수준에 따라 다르지만, SELECT가 먼저 실행되고, 그 트랜잭션이 끝나기 전에 UPDATE가 실행되면, SELECT가 데이터를 읽고 있는 동안 데이터가 업데이트될 수 있습니다. 이는 **Non-repeatable Read**로 이어질 수 있습니다.
- **UPDATE가 먼저 실행된 경우**: UPDATE가 실행되고 커밋되지 않은 상태에서 SELECT가 실행되면, 트랜잭션 격리 수준이 **Read Uncommitted**일 때 커밋되지 않은 데이터를 읽을 수 있습니다. **Read Committed** 이상에서는 커밋되지 않은 데이터는 SELECT에 노출되지 않습니다.

#### b. **SELECT와 INSERT 간의 상호작용**
- **SELECT가 먼저 실행된 경우**: SELECT가 특정 조건에 맞는 데이터를 조회하고, 트랜잭션 중간에 다른 트랜잭션에서 새로운 데이터를 INSERT하면, SELECT가 처음에 조회한 결과와 달라질 수 있습니다. 이는 **Phantom Read**로 이어집니다.
- **INSERT가 먼저 실행된 경우**: 새로운 데이터가 INSERT되고 커밋되지 않은 상태에서 SELECT가 실행되면, **Read Uncommitted**에서는 커밋되지 않은 데이터를 볼 수 있습니다. **Read Committed** 이상에서는 INSERT가 커밋되지 않으면 SELECT에서 조회되지 않습니다.

#### c. **UPDATE와 INSERT 간의 상호작용**
- **UPDATE가 먼저 실행된 경우**: 특정 조건에 맞는 데이터를 UPDATE한 후, 동일한 조건에 새로운 데이터를 INSERT하면, 두 트랜잭션의 충돌 가능성이 있습니다. 데이터의 무결성을 유지하기 위해 락이 사용될 수 있습니다.
- **INSERT가 먼저 실행된 경우**: 새 데이터가 INSERT된 후, 다른 트랜잭션에서 데이터를 UPDATE하려고 할 때, 락이나 충돌이 발생할 수 있습니다. 특히 **Serializable** 격리 수준에서는 이러한 충돌이 발생하지 않도록 트랜잭션을 직렬화할 수 있습니다.

---

### 4. 데이터베이스 락 (Locking)과 동시성 제어

**데이터베이스 락**은 트랜잭션 간의 간섭을 방지하기 위해 사용됩니다. 특히, 트랜잭션이 데이터를 읽거나 수정할 때, 다른 트랜잭션이 동일한 데이터에 접근하지 못하도록 락을 거는 방식입니다.

- **공유 락 (Shared Lock)**: SELECT와 같은 읽기 작업에서 사용되며, 다른 트랜잭션의 읽기를 허용하지만 쓰기는 허용하지 않습니다.
- **배타 락 (Exclusive Lock)**: UPDATE, DELETE와 같은 쓰기 작업에서 사용되며, 다른 트랜잭션이 해당 데이터에 접근하는 것을 모두 차단합니다.

---

**Serializable** 트랜잭션 격리 수준에서의 동작은 정확히 그렇게 되는 것은 아니지만, 매우 높은 수준의 **동시성 제어**가 이루어집니다. **Serializable**은 트랜잭션 간 **최고 수준의 격리**를 제공하지만, 그로 인해 발생하는 동작을 이해하는 것이 중요합니다.

### 1. **Serializable 트랜잭션 격리 수준의 동작**

**Serializable**은 트랜잭션이 마치 **직렬화**된 것처럼 동작하도록 보장합니다. 즉, 여러 트랜잭션이 동시에 실행되더라도 결과는 마치 **하나씩 순차적으로 처리된 것**과 같은 결과를 보장합니다. 이를 통해 데이터의 **일관성**을 극대화하지만, 동시에 성능 저하와 **동시성 문제**가 발생할 수 있습니다.

#### 주요 특징:
- **Phantom Read**, **Non-repeatable Read**, **Dirty Read**와 같은 문제는 모두 방지됩니다.
- 트랜잭션이 **데이터를 읽고 있는 동안**, 그 데이터에 대해 **다른 트랜잭션이 수정, 삭제, 삽입**할 수 없습니다. 데이터베이스는 이를 관리하기 위해 **락(lock)**을 사용하거나, **오류를 발생**시켜 트랜잭션 충돌을 방지합니다.

### 2. **JDBC에서 Serializable 격리 수준으로 SELECT 작업 시**

만약 JDBC **Connection**을 **Serializable** 격리 수준으로 설정하고 SELECT 작업을 실행하면, 해당 **트랜잭션 동안** 다음과 같은 일이 발생합니다:

1. **읽기 중 데이터 변경 금지**: 트랜잭션이 특정 데이터를 읽고 있는 동안, 다른 트랜잭션이 그 데이터를 **수정하거나 삭제**하려고 하면 차단됩니다. 데이터에 **읽기 락(Read Lock)** 또는 **공유 락(Shared Lock)**이 걸리며, 다른 트랜잭션이 그 데이터에 **쓰기 작업(INSERT, UPDATE, DELETE)**을 하려 할 때 **대기**하거나 **실패**하게 됩니다.

2. **쓰기 중 데이터 읽기 금지**: 반대로, 만약 다른 트랜잭션에서 이미 데이터에 대해 **쓰기 락(Exclusive Lock)**을 걸고 있다면, 그 데이터에 대한 **SELECT** 쿼리가 차단될 수 있습니다. 즉, SELECT 작업이 해당 데이터를 조회하려고 할 때 다른 트랜잭션에서 데이터를 변경 중이라면, SELECT 작업이 **대기**하거나 **실패**할 수 있습니다.

3. **데이터의 추가/삭제 차단 (Phantom Read 방지)**: Serializable 수준에서는 특정 범위의 데이터를 조회한 후, 그 범위 내에서 **새로운 데이터의 추가나 삭제**를 허용하지 않습니다. 이는 **Phantom Read**를 방지하기 위한 것이며, 데이터의 삽입이나 삭제가 일어나지 않도록 **해당 범위에 락**이 걸리게 됩니다.

### 3. **Serializable의 실제 동작 방식**

데이터베이스마다 **Serializable 격리 수준**을 구현하는 방식이 다르지만, 일반적으로는 **락**과 **트랜잭션 충돌 탐지**를 통해 이루어집니다.

- **락 기반 접근**: 많은 데이터베이스에서는 **Serializable** 트랜잭션이 실행될 때, 읽거나 쓰는 데이터에 대해 **락**을 사용합니다. 읽기 작업 중에 데이터가 변경되지 않도록 **락**을 설정하고, 쓰기 작업 중에 읽기 작업이 들어오지 않도록 **배타적 락(Exclusive Lock)**을 사용합니다.
- **오류 기반 접근(충돌 탐지)**: 일부 데이터베이스는 락 대신 **MVCC(Multi-Version Concurrency Control)** 또는 **충돌 탐지**를 사용합니다. 즉, 트랜잭션이 종료될 때 서로 간에 충돌이 발생하면 트랜잭션을 **롤백**시키고, **재시도**하도록 합니다. 이는 락을 과도하게 사용하지 않고 동시성을 높이려는 방식입니다.

### 4. **Serializable 수준에서의 동작 예시**

다음은 **Serializable** 트랜잭션 격리 수준에서의 동작을 이해하기 위한 간단한 예시입니다.

#### 예시 1: 동일한 데이터를 두 트랜잭션이 동시에 처리
1. **트랜잭션 A**: `SELECT * FROM users WHERE age > 30` (Serializable 트랜잭션)
   - 이 쿼리가 실행되면, 해당 조건을 만족하는 모든 데이터에 **락**이 걸립니다.
   
2. **트랜잭션 B**: `UPDATE users SET age = 35 WHERE id = 101`
   - 트랜잭션 A가 아직 완료되지 않았다면, 트랜잭션 B는 해당 데이터를 **수정할 수 없습니다**. 트랜잭션 B는 **대기**하거나 **실패**하게 됩니다.

3. **트랜잭션 A**가 완료된 후, 트랜잭션 B가 실행됩니다.

#### 예시 2: Phantom Read 방지
1. **트랜잭션 A**: `SELECT * FROM orders WHERE order_date = '2023-01-01'`
   - 이 쿼리에서 특정 범위의 데이터에 대한 조회가 이루어지며, 해당 범위에 **락**이 걸립니다.
   
2. **트랜잭션 B**: `INSERT INTO orders (order_date, amount) VALUES ('2023-01-01', 500)`
   - 트랜잭션 A가 끝나기 전에는 트랜잭션 B가 새로운 주문을 추가할 수 없습니다. **Serializable**은 새로운 데이터의 추가도 차단하여 **Phantom Read**를 방지합니다.

### 5. **정리: 다른 작업의 접근 차단 여부**

질문으로 돌아가서, **Serializable** 트랜잭션 격리 수준으로 **Connection을 열고 SELECT를 실행할 때**:
- 쿼리가 실행되고 있는 동안 **다른 트랜잭션이 해당 테이블의 데이터에 대해 수정(UPDATE) 또는 삽입(INSERT)**을 시도하면, **락**이 걸리기 때문에 접근이 제한될 수 있습니다.
- 즉, 해당 트랜잭션이 읽고 있는 데이터는 다른 트랜잭션이 **수정하거나 삭제할 수 없으며**, 새로운 데이터를 삽입하려고 해도 차단될 수 있습니다.
- 그러나 테이블 전체에 대한 락이 걸리는 것은 아니고, **해당 트랜잭션이 접근하는 데이터 범위**(조건에 맞는 행들)에 대해서만 락이 발생합니다.

### 모던 트랜잭션 관리: Redis 분산락과 Kafka 기반 SAGA 패턴을 활용한 효율적 트랜잭션 관리

현대의 분산 시스템에서는 데이터 일관성을 유지하면서도 성능을 최적화하기 위해 다양한 **트랜잭션 관리 기술**이 필요합니다. 전통적인 **ACID 트랜잭션**은 단일 데이터베이스에서의 일관성을 보장하지만, **마이크로서비스 아키텍처**나 **분산 시스템**에서는 이를 적용하는 것이 복잡해질 수 있습니다. 이때, **Redis 분산락**과 **Kafka 기반 SAGA 패턴**과 같은 기술을 통해 **애플리케이션 레이어에서 효율적인 트랜잭션 관리**가 가능해집니다.

---

### 1. **Redis 분산락 (Distributed Lock)**

**Redis 분산락**은 **분산 환경**에서 리소스를 안전하게 관리하기 위한 **락 메커니즘**입니다. 여러 인스턴스가 동시에 동일한 리소스에 접근하려 할 때, **데이터 일관성**을 유지하기 위해 **동시성 제어**가 필요합니다. Redis는 가볍고 빠른 인메모리 데이터 스토리지로, 이를 활용하여 **분산 락**을 관리할 수 있습니다.

#### a. **Redis 분산락의 기본 원리**
- **SETNX (Set if Not Exists)**: Redis의 `SETNX` 명령어는 **키가 존재하지 않을 때**에만 값을 설정하는 명령입니다. 이를 사용하여 락을 얻을 수 있습니다.
- **Expire Time (TTL)**: 락이 걸린 상태가 무한정 지속되지 않도록, 락에 **TTL(Time-to-Live)**을 설정하여 락을 자동으로 해제합니다.
- **락 해제**: 락을 점유한 프로세스가 작업을 완료하면, Redis에서 해당 락을 **해제**하여 다른 프로세스가 리소스를 사용할 수 있도록 합니다.

#### b. **Redis 분산락 구현 예시**
다음은 Redis를 활용한 **분산락**의 간단한 구현입니다.

```java
// RedisTemplate를 사용한 분산락 구현 예시
public boolean acquireLock(RedisTemplate<String, String> redisTemplate, String lockKey, String lockValue, long expireTime) {
    // SETNX 명령어로 락 설정
    Boolean success = redisTemplate.opsForValue().setIfAbsent(lockKey, lockValue, expireTime, TimeUnit.SECONDS);
    return Boolean.TRUE.equals(success);  // 락 획득 여부 반환
}

public void releaseLock(RedisTemplate<String, String> redisTemplate, String lockKey, String lockValue) {
    // 락을 해제할 때, 락이 자신이 설정한 것인지 확인 후 해제
    String currentValue = redisTemplate.opsForValue().get(lockKey);
    if (lockValue.equals(currentValue)) {
        redisTemplate.delete(lockKey);
    }
}
```

#### c. **Redis 분산락의 장점**
- **빠르고 가벼움**: Redis는 **인메모리 데이터베이스**로, 락을 빠르게 획득하고 해제할 수 있습니다.
- **분산 환경 지원**: 여러 애플리케이션 인스턴스에서 Redis를 사용해 **동시성 제어**를 손쉽게 관리할 수 있습니다.
- **TTL 설정**: 락을 오래 점유하는 상황을 방지하기 위해 **TTL**을 설정하여 자동으로 해제되는 기능을 지원합니다.

#### d. **Redis 분산락의 한계**
- Redis 분산락은 **강력한 일관성**을 제공하지 않기 때문에, 락 해제의 **경쟁 상태**가 발생할 수 있습니다. 이를 해결하기 위해 Redis에서는 **Redlock 알고리즘**과 같은 **복잡한 분산락 구현**이 필요할 수 있습니다.
  
---

### 2. **Kafka를 활용한 SAGA 패턴**

**SAGA 패턴**은 **분산 트랜잭션**을 관리하기 위한 **트랜잭션 관리 패턴**으로, **각 서비스별로 로컬 트랜잭션을 실행**하고 **복구 절차(보상 트랜잭션)**를 통해 전체 시스템의 일관성을 유지합니다. **Kafka**와 같은 메시징 시스템을 활용하면 **SAGA 패턴**을 더욱 효율적으로 관리할 수 있습니다.

#### a. **SAGA 패턴의 두 가지 유형**
1. **Choreography**: 각 서비스가 **자율적으로** 트랜잭션을 처리하고, 다음 단계의 트랜잭션을 **이벤트**로 트리거합니다. **Kafka**를 활용한 **이벤트 기반 트랜잭션 관리**에 적합합니다.
   
2. **Orchestration**: 중앙 **SAGA 코디네이터**가 모든 트랜잭션 단계를 관리하며, 실패 시 보상 작업을 수행합니다. **중앙화된 제어**를 필요로 하는 경우 사용됩니다.

#### b. **Kafka를 활용한 SAGA Choreography 패턴**
Kafka는 **이벤트 스트리밍** 시스템으로, 각 서비스 간의 **이벤트 전달**을 통해 **트랜잭션**을 관리할 수 있습니다. 각 서비스는 Kafka의 **토픽**을 통해 다음 트랜잭션 단계를 트리거하고, 각 단계에서 로컬 트랜잭션을 처리합니다.

##### **SAGA Choreography 패턴 예시** (Kafka 활용):
1. **주문 서비스**가 주문을 생성하고, Kafka에 `OrderCreated` 이벤트를 발행합니다.
2. **재고 서비스**가 `OrderCreated` 이벤트를 소비하고, 재고를 차감한 후 Kafka에 `StockReserved` 이벤트를 발행합니다.
3. **결제 서비스**가 `StockReserved` 이벤트를 소비하고 결제를 처리한 후 `PaymentProcessed` 이벤트를 발행합니다.
4. 모든 트랜잭션이 성공적으로 완료되면 주문이 완료됩니다.

만약 어느 단계에서 오류가 발생하면, Kafka를 통해 **보상 트랜잭션**을 실행하여 시스템 상태를 롤백합니다.

```java
// Kafka Consumer 예시: 주문 서비스
@KafkaListener(topics = "OrderCreated", groupId = "saga-group")
public void handleOrderCreated(OrderCreatedEvent event) {
    try {
        // 로컬 트랜잭션 수행: 재고 차감
        inventoryService.reserveStock(event.getOrderId());

        // 성공 시 다음 이벤트 발행
        kafkaTemplate.send("StockReserved", new StockReservedEvent(event.getOrderId()));
    } catch (Exception e) {
        // 실패 시 보상 트랜잭션 수행
        kafkaTemplate.send("OrderCompensation", new OrderCompensationEvent(event.getOrderId()));
    }
}
```

#### c. **Kafka 기반 SAGA 패턴의 장점**
- **이벤트 기반 아키텍처**: Kafka의 **이벤트 스트리밍** 기능을 통해 각 서비스 간의 트랜잭션을 **비동기적으로** 처리할 수 있습니다.
- **확장성**: Kafka는 고성능의 **메시지 처리**를 지원하므로, 많은 트랜잭션을 처리하는 분산 시스템에 적합합니다.
- **복구 절차 관리**: 트랜잭션 실패 시 보상 트랜잭션을 Kafka 이벤트로 쉽게 관리할 수 있습니다.

#### d. **Kafka 기반 SAGA 패턴의 단점**
- **복잡성 증가**: 각 트랜잭션 단계별로 이벤트를 주고받아야 하므로, **비즈니스 로직이 복잡**해질 수 있습니다.
- **보상 트랜잭션의 설계**: 실패 시 어떻게 **보상 트랜잭션**을 처리할지 명확히 설계해야 하며, 이로 인해 관리가 복잡해질 수 있습니다.

---

### 결론: Redis 분산락과 Kafka 기반 SAGA 패턴의 활용

1. **Redis 분산락**은 분산 시스템에서 **동시성 제어**를 관리하는 데 유용하며, Redis의 빠른 인메모리 특성을 활용하여 **리소스 잠금**을 효과적으로 처리할 수 있습니다. 분산 환경에서 **경쟁 상태**를 방지하고, 자원을 안전하게 관리할 수 있습니다.
   
2. **Kafka 기반 SAGA 패턴**은 **분산 트랜잭션**을 관리하는 강력한 패턴으로, **마이크로서비스 아키텍처**에서 서비스 간 트랜잭션을 비동기적으로 연결하고, Kafka의 메시징 기능을 통해 **확장성**과 **내결함성**을 제공할 수 있습니다. 각 서비스의 로컬 트랜잭션을 독립적으로 처리하면서, 전체적으로 **데이터 일관성**을 보장할 수 있습니다.
