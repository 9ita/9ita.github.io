---
author: "seonuk1218"
title: "Title"
image: ""
draft: false
date: 2024-09-20
description: "abstraction"
tags: ["abstraction"]
archives: ["2024/09"]
---

### 추상화에 대한 생각 정리

#### 코드 품질? 어플리케이션 성능?

Message Broker를 도입하면 성능이 어떻게 될까, ELK를 도입하면 어떤 변화가 있을까… 이런 얘기를 하다 보면, 보통 말하는 건 성능에 관한 것.  
단순히 시스템을 성능적으로만 개선하는 것도 중요하지만, 사실 적절한 **추상화**를 거치면 더 유연하고 유지보수하기 쉬운 코드가 된다는 걸 잊지 말아야 할 듯.

#### 품질 좋은 코드란?  

- 확장성, 유지보수성  
- 가독성, 직관성  
- 그리고 **추상화**와 깊게 연관.  

#### 성능 좋은 어플리케이션이란?

- 벤치마크 돌려서 실제로 성능 확인해야 하고  
- 단위 테스트, 통합 테스트로 성능을 꾸준히 체크해야 함  
- 각 솔루션이 주는 성능 이점을 파악하는 것도 중요함.  

---

## 추상화에 대한 생각

예전에는 이렇게 생각했다.  
"굳이 추상화를 내가 고민해야 하나? 이미 잘 만들어진 도구(SPI)를 이용하면 충분하지 않나?"  
예를 들어, SpringCache나 JPA 같은 거.  
**추상화 도구**를 이용하면 캐시나 데이터베이스 관련해서 직접 구현체를 신경 쓰지 않고도 해결할 수 있으니까, 그냥 그걸 쓰면 되는 거 아닌가 싶었다.  

근데 최근에 드는 생각은 조금 다름.  
오픈소스 구조를 뜯어보면 그들의 **추상화 전략**이 얼마나 중요한지 알게 된다. 그리고 내부 시스템에 대한 추상화는 오픈소스가 알아서 해주는 게 아니니까… 여기에 신경 써야겠다는 생각이 점점 든다.  

강한 결합을 가진 코드를 많이 봐왔는데, 그런 구조는 나중에 변경할 때나 확장할 때 진짜 힘들다. 결국, 유연성을 고려한 추상화가 필요하다는 생각이 든다.

---

## 어떻게 공부할까?

- Spring-integration 같은 오픈소스 프로젝트 문서나 코드를 보면서 추상화 인사이트 얻기  
- 그 외에도 다양한 오픈소스 구조 분석하면서 적용해보기  

---

## 오픈소스 추상화 예시

### Spring-integration (https://spring.io/projects/spring-integration)

Spring-Integration은 다양한 시스템 간 메시지 기반 통합을 쉽게 처리할 수 있도록 설계된 프레임워크이다. 이 프레임워크는 복잡한 메시지 처리 로직을 추상화 계층을 통해 단순화하고, 확장성과 유연성을 제공한다.

#### MessageChannel

`MessageChannel`은 메시지를 전달하는 경로를 추상화한 인터페이스이다. 메시지 흐름의 경로를 분리하고, 다양한 구현체를 통해 메시지를 어떻게 전달할지 선택할 수 있다. 예를 들어, `DirectChannel`은 동기적인 메시지 전달을, `QueueChannel`은 비동기적인 메시지 전달을 가능하게 한다. 이를 통해 시스템의 성능 요구나 아키텍처 특성에 맞춰 유연하게 메시지 채널을 구성할 수 있다.

#### Message

`Message` 인터페이스는 메시지 자체를 추상화한 객체로, 페이로드(실제 데이터)와 헤더 정보를 포함한다. 이를 통해 메시지가 어디에서 왔든지 상관없이 일관된 방식으로 메시지를 처리할 수 있다. 각 메시지에는 필수 데이터뿐 아니라, 부가적인 메타데이터(헤더)도 포함되어 있어, 다양한 메시지 처리 로직에 유연하게 대응할 수 있다.

#### MessageHandler

`MessageHandler`는 수신된 메시지를 처리하는 역할을 담당하는 추상화 계층이다. 메시지 핸들러는 다양한 메시지 처리 로직을 캡슐화하며, `ServiceActivator`, `Router`, `Transformer`와 같은 구체적인 구현체들이 이를 상속받아 다양한 메시지 처리 방식(예: 변환, 라우팅, 호출 등)을 제공한다. 이를 통해 비즈니스 로직에서 메시지 처리의 복잡성을 숨기고, 유연한 확장 가능성을 제공한다.

#### Poller

`Poller`는 메시지를 가져오는 방식을 추상화하는 인터페이스로, 주기적으로 메시지를 가져오거나 특정 조건에서만 메시지를 가져오는 다양한 방식으로 설정할 수 있다. `PollerMetadata`를 사용해 폴링 주기, 조건, 스레드 수 등을 설정할 수 있으며, 이를 통해 다양한 메시지 소스에서 일관된 방식으로 메시지를 처리할 수 있는 유연성을 제공한다.

#### Gateway

`Gateway`는 외부 시스템과의 통합 지점을 추상화하는 요소로, 외부와의 통신을 캡슐화하여 통합 작업을 단순화한다. 개발자는 SOAP, REST, JMS 등 다양한 통신 방식을 신경 쓰지 않고 일관된 방식으로 외부 시스템과 통신할 수 있으며, 이는 복잡한 통합 시나리오에서 시스템 간 의존성을 줄이고, 변경에 유연하게 대응할 수 있도록 설계되었다.

### Spring Framework 예시
- **ApplicationContext**: Spring의 핵심 컨테이너로, Bean 관리, 의존성 주입 등을 담당하는데, 이 역시 추상화 계층이다. 구체적으로는 다양한 ApplicationContext 구현체들이 존재하고(예: `ClassPathXmlApplicationContext`, `AnnotationConfigApplicationContext`), 개발자는 이를 신경 쓰지 않고 일관된 방식으로 Bean을 사용할 수 있다.
  
- **PlatformTransactionManager**: 트랜잭션 관리를 추상화한 인터페이스. 이 인터페이스를 통해 여러 트랜잭션 전략(예: JPA, JDBC, JTA 등)을 하나의 통일된 API로 관리할 수 있다. `DataSourceTransactionManager`, `JpaTransactionManager` 등이 이 인터페이스를 구현해서 각각의 트랜잭션 관리 방식을 처리.

- **HandlerInterceptor**: Spring MVC에서 요청 처리 전에 가로채는 인터페이스인데, 구체적인 가로채기 로직은 구현체에서 처리된다. `HandlerInterceptor`를 이용해 공통 로직을 추상화하고, 구체적인 동작을 각 애플리케이션 요구 사항에 맞게 구현할 수 있다.

### Hibernate 예시
- **Criteria API**: Hibernate에서 동적 쿼리를 작성하기 위한 추상화 계층. 이 API를 통해 SQL 구문을 직접 작성하지 않고도 데이터베이스 질의를 생성할 수 있다. 이는 구체적인 SQL 구문에서 추상화된 형태로, 다양한 데이터베이스와 유연하게 동작할 수 있게 해준다.

### 기타 오픈소스 예시
- **Apache Kafka - KafkaConsumer / KafkaProducer**: Kafka에서 메시지를 생산하고 소비하는 클라이언트를 추상화한 인터페이스들. 실제 메시지 브로커와의 통신을 추상화하고, 개발자는 메시지의 생산과 소비에만 집중할 수 있게 해준다. 이를 통해 다양한 브로커 설정을 일관된 방식으로 사용할 수 있다.

- **Apache Camel**: Camel의 **RouteBuilder**는 다양한 메시징 시스템을 연결하는 추상화 도구다. 이를 통해 파일 시스템, 메시지 큐, HTTP 등의 서로 다른 시스템 간의 통신을 추상화하여 하나의 통일된 API로 사용할 수 있다. 이 역시 메시지 시스템 간의 상호 작용을 유연하게 처리할 수 있게 해준다.

- **JMS (Java Message Service) - ConnectionFactory**: JMS에서는 메시지 브로커와의 연결을 관리하는 추상화 계층으로 `ConnectionFactory`를 사용한다. 이를 통해 여러 종류의 메시징 시스템과 상관없이 일관된 방식으로 메시징 처리를 할 수 있다.

---