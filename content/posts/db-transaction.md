### 데이터베이스 트랜잭션에 관한 고찰

**데이터베이스 트랜잭션**은 하나의 작업을 논리적으로 묶어서 처리하는 단위입니다. 트랜잭션은 **ACID** 속성(Atomicity, Consistency, Isolation, Durability)을 따르며, 이 중 **Isolation(고립성)**은 여러 트랜잭션이 동시에 실행될 때 발생하는 **간섭**을 어떻게 제어할 것인지 결정하는 핵심 요소입니다.

트랜잭션에서 **SELECT(읽기)**, **UPDATE(수정)**, **INSERT(삽입)** 작업은 각기 다른 데이터 처리 작업을 수행하지만, 동시에 실행될 때 서로 간섭을 줄 수 있습니다. 이 간섭을 어떻게 제어하는가는 **트랜잭션 격리 수준**과 **데이터베이스 락**과 같은 메커니즘에 따라 달라집니다.

---

### 1. 트랜잭션 간섭(Interference)의 유형

데이터베이스 트랜잭션은 서로 간섭을 줄 수 있으며, 이로 인해 발생하는 문제는 일반적으로 다음과 같은 형태로 나타납니다:

1. **Dirty Read (더티 리드)**:
   - 한 트랜잭션이 다른 트랜잭션에서 **커밋되지 않은 데이터**를 읽는 상황입니다.
   - 예: 트랜잭션 A가 데이터를 수정했지만 아직 커밋하지 않은 상태에서, 트랜잭션 B가 그 데이터를 읽으면, 트랜잭션 A가 롤백할 경우 B는 잘못된 데이터를 사용하게 됩니다.

2. **Non-repeatable Read (반복되지 않는 읽기)**:
   - 한 트랜잭션이 동일한 데이터를 여러 번 읽는 동안, 다른 트랜잭션이 그 데이터를 수정하는 상황입니다.
   - 예: 트랜잭션 A가 데이터를 읽고, 트랜잭션 B가 그 데이터를 수정한 후 다시 트랜잭션 A가 읽으면 다른 값이 나옵니다.

3. **Phantom Read (팬텀 리드)**:
   - 한 트랜잭션이 특정 조건에 맞는 데이터를 읽는 동안, 다른 트랜잭션이 새로운 데이터를 **삽입하거나 삭제**하여, 같은 쿼리에서 다른 결과가 나오는 상황입니다.
   - 예: 트랜잭션 A가 `WHERE` 조건으로 특정 데이터를 조회한 후, 트랜잭션 B가 새로운 데이터를 삽입하여 트랜잭션 A가 다시 조회할 때 이전과 다른 결과가 나옵니다.

---

### 2. 트랜잭션 격리 수준 (Isolation Level)

SQL 표준에서는 **트랜잭션 격리 수준**을 통해 트랜잭션 간의 간섭을 제어합니다. 각 수준은 간섭의 정도를 결정하며, 상호작용하는 트랜잭션의 읽기/쓰기 작업에 따라 데이터베이스의 성능과 일관성에 영향을 미칩니다.

#### 트랜잭션 격리 수준의 종류

1. **Read Uncommitted** (가장 낮은 격리 수준)
   - 트랜잭션이 커밋되지 않은 데이터도 읽을 수 있습니다.
   - **Dirty Read** 가능.
   - SELECT가 UPDATE나 INSERT 작업에 간섭을 받을 수 있음.

2. **Read Committed** (기본 수준, 대부분의 DBMS의 기본값)
   - 커밋된 데이터만 읽을 수 있습니다.
   - **Dirty Read**는 발생하지 않지만, **Non-repeatable Read**가 발생할 수 있습니다.
   - 트랜잭션이 SELECT를 두 번 실행하면, 그 사이에 다른 트랜잭션이 데이터를 수정할 수 있습니다.

3. **Repeatable Read** (격리 수준이 더 높은 단계)
   - 트랜잭션 내에서 동일한 데이터를 여러 번 읽어도 항상 동일한 결과를 반환합니다.
   - **Non-repeatable Read**는 발생하지 않지만, **Phantom Read**는 발생할 수 있습니다.
   - UPDATE와 INSERT 작업은 SELECT 작업에 간섭을 줄 가능성이 적습니다.

4. **Serializable** (가장 높은 격리 수준)
   - 모든 트랜잭션이 서로 직렬화되며, 트랜잭션이 독립적으로 처리됩니다.
   - **Dirty Read**, **Non-repeatable Read**, **Phantom Read**가 모두 방지됩니다.
   - 성능이 떨어질 수 있으나, 트랜잭션 간의 간섭이 발생하지 않습니다.

#### 격리 수준이 간섭에 미치는 영향
- **Read Uncommitted**에서는 UPDATE 또는 INSERT가 SELECT 작업을 방해할 수 있으며, 아직 커밋되지 않은 데이터가 SELECT에 노출될 수 있습니다.
- **Read Committed** 이상에서는 커밋된 데이터만 노출되므로, SELECT가 UPDATE나 INSERT에 의한 간섭을 받지 않습니다. 다만 트랜잭션이 실행되는 동안 데이터가 변할 수 있어 반복되지 않는 읽기가 발생할 수 있습니다.
- **Repeatable Read**나 **Serializable** 수준에서는 간섭이 거의 발생하지 않으며, SELECT 작업은 트랜잭션이 끝날 때까지 동일한 데이터를 반환하도록 보장됩니다.

---

### 3. 테이블에서의 SELECT, UPDATE, INSERT의 상호작용

**SELECT, UPDATE, INSERT**가 서로 간섭을 주는지는 **데이터베이스 락킹 메커니즘**과 **트랜잭션 격리 수준**에 따라 달라집니다. 일반적으로, UPDATE와 INSERT는 **쓰기 작업**으로, SELECT는 **읽기 작업**으로 구분되며, 상호 간섭은 다음과 같은 방식으로 발생할 수 있습니다:

#### a. **SELECT와 UPDATE 간의 상호작용**
- **SELECT가 먼저 실행된 경우**: 트랜잭션 격리 수준에 따라 다르지만, SELECT가 먼저 실행되고, 그 트랜잭션이 끝나기 전에 UPDATE가 실행되면, SELECT가 데이터를 읽고 있는 동안 데이터가 업데이트될 수 있습니다. 이는 **Non-repeatable Read**로 이어질 수 있습니다.
- **UPDATE가 먼저 실행된 경우**: UPDATE가 실행되고 커밋되지 않은 상태에서 SELECT가 실행되면, 트랜잭션 격리 수준이 **Read Uncommitted**일 때 커밋되지 않은 데이터를 읽을 수 있습니다. **Read Committed** 이상에서는 커밋되지 않은 데이터는 SELECT에 노출되지 않습니다.

#### b. **SELECT와 INSERT 간의 상호작용**
- **SELECT가 먼저 실행된 경우**: SELECT가 특정 조건에 맞는 데이터를 조회하고, 트랜잭션 중간에 다른 트랜잭션에서 새로운 데이터를 INSERT하면, SELECT가 처음에 조회한 결과와 달라질 수 있습니다. 이는 **Phantom Read**로 이어집니다.
- **INSERT가 먼저 실행된 경우**: 새로운 데이터가 INSERT되고 커밋되지 않은 상태에서 SELECT가 실행되면, **Read Uncommitted**에서는 커밋되지 않은 데이터를 볼 수 있습니다. **Read Committed** 이상에서는 INSERT가 커밋되지 않으면 SELECT에서 조회되지 않습니다.

#### c. **UPDATE와 INSERT 간의 상호작용**
- **UPDATE가 먼저 실행된 경우**: 특정 조건에 맞는 데이터를 UPDATE한 후, 동일한 조건에 새로운 데이터를 INSERT하면, 두 트랜잭션의 충돌 가능성이 있습니다. 데이터의 무결성을 유지하기 위해 락이 사용될 수 있습니다.
- **INSERT가 먼저 실행된 경우**: 새 데이터가 INSERT된 후, 다른 트랜잭션에서 데이터를 UPDATE하려고 할 때, 락이나 충돌이 발생할 수 있습니다. 특히 **Serializable** 격리 수준에서는 이러한 충돌이 발생하지 않도록 트랜잭션을 직렬화할 수 있습니다.

---

### 4. 데이터베이스 락 (Locking)과 동시성 제어

**데이터베이스 락**은 트랜잭션 간의 간섭을 방지하기 위해 사용됩니다. 특히, 트랜잭션이 데이터를 읽거나 수정할 때, 다른 트랜잭션이 동일한 데이터에 접근하지 못하도록 락을 거는 방식입니다.

- **공유 락 (Shared Lock)**: SELECT와 같은 읽기 작업에서 사용되며, 다른 트랜잭션의 읽기를 허용하지만 쓰기는 허용하지 않습니다.
- **배타 락 (Exclusive Lock)**: UPDATE, DELETE와 같은 쓰기 작업에서 사용되며, 다른 트랜잭션이 해당 데이터에 접근하는 것을 모두 차단합니다.

---

**Serializable** 트랜잭션 격리 수준에서의 동작은 정확히 그렇게 되는 것은 아니지만, 매우 높은 수준의 **동시성 제어**가 이루어집니다. **Serializable**은 트랜잭션 간 **최고 수준의 격리**를 제공하지만, 그로 인해 발생하는 동작을 이해하는 것이 중요합니다.

### 1. **Serializable 트랜잭션 격리 수준의 동작**

**Serializable**은 트랜잭션이 마치 **직렬화**된 것처럼 동작하도록 보장합니다. 즉, 여러 트랜잭션이 동시에 실행되더라도 결과는 마치 **하나씩 순차적으로 처리된 것**과 같은 결과를 보장합니다. 이를 통해 데이터의 **일관성**을 극대화하지만, 동시에 성능 저하와 **동시성 문제**가 발생할 수 있습니다.

#### 주요 특징:
- **Phantom Read**, **Non-repeatable Read**, **Dirty Read**와 같은 문제는 모두 방지됩니다.
- 트랜잭션이 **데이터를 읽고 있는 동안**, 그 데이터에 대해 **다른 트랜잭션이 수정, 삭제, 삽입**할 수 없습니다. 데이터베이스는 이를 관리하기 위해 **락(lock)**을 사용하거나, **오류를 발생**시켜 트랜잭션 충돌을 방지합니다.

### 2. **JDBC에서 Serializable 격리 수준으로 SELECT 작업 시**

만약 JDBC **Connection**을 **Serializable** 격리 수준으로 설정하고 SELECT 작업을 실행하면, 해당 **트랜잭션 동안** 다음과 같은 일이 발생합니다:

1. **읽기 중 데이터 변경 금지**: 트랜잭션이 특정 데이터를 읽고 있는 동안, 다른 트랜잭션이 그 데이터를 **수정하거나 삭제**하려고 하면 차단됩니다. 데이터에 **읽기 락(Read Lock)** 또는 **공유 락(Shared Lock)**이 걸리며, 다른 트랜잭션이 그 데이터에 **쓰기 작업(INSERT, UPDATE, DELETE)**을 하려 할 때 **대기**하거나 **실패**하게 됩니다.

2. **쓰기 중 데이터 읽기 금지**: 반대로, 만약 다른 트랜잭션에서 이미 데이터에 대해 **쓰기 락(Exclusive Lock)**을 걸고 있다면, 그 데이터에 대한 **SELECT** 쿼리가 차단될 수 있습니다. 즉, SELECT 작업이 해당 데이터를 조회하려고 할 때 다른 트랜잭션에서 데이터를 변경 중이라면, SELECT 작업이 **대기**하거나 **실패**할 수 있습니다.

3. **데이터의 추가/삭제 차단 (Phantom Read 방지)**: Serializable 수준에서는 특정 범위의 데이터를 조회한 후, 그 범위 내에서 **새로운 데이터의 추가나 삭제**를 허용하지 않습니다. 이는 **Phantom Read**를 방지하기 위한 것이며, 데이터의 삽입이나 삭제가 일어나지 않도록 **해당 범위에 락**이 걸리게 됩니다.

### 3. **Serializable의 실제 동작 방식**

데이터베이스마다 **Serializable 격리 수준**을 구현하는 방식이 다르지만, 일반적으로는 **락**과 **트랜잭션 충돌 탐지**를 통해 이루어집니다.

- **락 기반 접근**: 많은 데이터베이스에서는 **Serializable** 트랜잭션이 실행될 때, 읽거나 쓰는 데이터에 대해 **락**을 사용합니다. 읽기 작업 중에 데이터가 변경되지 않도록 **락**을 설정하고, 쓰기 작업 중에 읽기 작업이 들어오지 않도록 **배타적 락(Exclusive Lock)**을 사용합니다.
- **오류 기반 접근(충돌 탐지)**: 일부 데이터베이스는 락 대신 **MVCC(Multi-Version Concurrency Control)** 또는 **충돌 탐지**를 사용합니다. 즉, 트랜잭션이 종료될 때 서로 간에 충돌이 발생하면 트랜잭션을 **롤백**시키고, **재시도**하도록 합니다. 이는 락을 과도하게 사용하지 않고 동시성을 높이려는 방식입니다.

### 4. **Serializable 수준에서의 동작 예시**

다음은 **Serializable** 트랜잭션 격리 수준에서의 동작을 이해하기 위한 간단한 예시입니다.

#### 예시 1: 동일한 데이터를 두 트랜잭션이 동시에 처리
1. **트랜잭션 A**: `SELECT * FROM users WHERE age > 30` (Serializable 트랜잭션)
   - 이 쿼리가 실행되면, 해당 조건을 만족하는 모든 데이터에 **락**이 걸립니다.
   
2. **트랜잭션 B**: `UPDATE users SET age = 35 WHERE id = 101`
   - 트랜잭션 A가 아직 완료되지 않았다면, 트랜잭션 B는 해당 데이터를 **수정할 수 없습니다**. 트랜잭션 B는 **대기**하거나 **실패**하게 됩니다.

3. **트랜잭션 A**가 완료된 후, 트랜잭션 B가 실행됩니다.

#### 예시 2: Phantom Read 방지
1. **트랜잭션 A**: `SELECT * FROM orders WHERE order_date = '2023-01-01'`
   - 이 쿼리에서 특정 범위의 데이터에 대한 조회가 이루어지며, 해당 범위에 **락**이 걸립니다.
   
2. **트랜잭션 B**: `INSERT INTO orders (order_date, amount) VALUES ('2023-01-01', 500)`
   - 트랜잭션 A가 끝나기 전에는 트랜잭션 B가 새로운 주문을 추가할 수 없습니다. **Serializable**은 새로운 데이터의 추가도 차단하여 **Phantom Read**를 방지합니다.

### 5. **정리: 다른 작업의 접근 차단 여부**

질문으로 돌아가서, **Serializable** 트랜잭션 격리 수준으로 **Connection을 열고 SELECT를 실행할 때**:
- 쿼리가 실행되고 있는 동안 **다른 트랜잭션이 해당 테이블의 데이터에 대해 수정(UPDATE) 또는 삽입(INSERT)**을 시도하면, **락**이 걸리기 때문에 접근이 제한될 수 있습니다.
- 즉, 해당 트랜잭션이 읽고 있는 데이터는 다른 트랜잭션이 **수정하거나 삭제할 수 없으며**, 새로운 데이터를 삽입하려고 해도 차단될 수 있습니다.
- 그러나 테이블 전체에 대한 락이 걸리는 것은 아니고, **해당 트랜잭션이 접근하는 데이터 범위**(조건에 맞는 행들)에 대해서만 락이 발생합니다.
