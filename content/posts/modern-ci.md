1. Rolling-Upate
2. Bule-Green
3. Canary


### Rolling Deployment: CI에서의 롤링 배포

**Rolling Deployment**는 **지속적 통합(Continuous Integration, CI)** 및 **지속적 배포(Continuous Delivery, CD)**의 핵심적인 배포 전략 중 하나로, 새로운 애플리케이션 버전을 배포할 때 기존 애플리케이션 인스턴스를 한 번에 하나씩 점진적으로 대체하는 방식입니다. 이를 통해 **무중단 배포**와 **서비스 가용성**을 유지할 수 있으며, 사용자는 배포 중에도 애플리케이션을 계속 사용할 수 있습니다.

---

### 1. **Rolling Deployment의 개념**

**Rolling Deployment**는 기존에 실행 중인 애플리케이션 인스턴스를 단계적으로 새로운 버전으로 대체하는 방식으로, **점진적 업그레이드**를 의미합니다. 예를 들어, 여러 인스턴스(Pod, 서버 등)로 운영되는 서비스에서 **하나씩 교체**하면서 배포하는 전략입니다.

- 기존 인스턴스를 **하나씩 종료**하고, 새로운 버전의 인스턴스를 실행하여 전체 애플리케이션을 새로운 버전으로 대체합니다.
- 전체 인프라에서 새로운 버전이 점진적으로 배포되기 때문에 **다운타임이 없거나 최소화**됩니다.

---

### 2. **Rolling Deployment의 주요 특징**

- **무중단 배포**: 서비스 중단 없이 새로운 버전의 애플리케이션을 배포할 수 있습니다.
- **점진적 배포**: 기존 인스턴스가 점진적으로 교체되며, 사용자 요청은 여전히 기존 인스턴스에서 처리될 수 있습니다.
- **간단한 롤백 가능**: 새로운 버전 배포 도중 문제가 발생하면, 문제된 인스턴스만 롤백할 수 있으며, 배포 과정을 역순으로 처리하여 점진적으로 롤백할 수 있습니다.
- **리소스 효율성**: 기존 인스턴스를 순차적으로 대체하는 방식이므로, 추가적인 리소스를 많이 필요로 하지 않습니다. 새로운 버전의 인스턴스를 배포할 때 기존 인스턴스를 제거하기 때문에 중복된 리소스 사용을 최소화할 수 있습니다.

---

### 3. **Rolling Deployment 과정**

1. **기존 버전 실행 중**: 현재 애플리케이션의 여러 인스턴스가 실행 중이며, 사용자 요청을 처리하고 있습니다.
2. **새로운 버전의 배포 시작**: 새로운 애플리케이션 버전의 인스턴스가 **하나씩 생성**되고, 기존 인스턴스는 종료됩니다.
3. **교체 작업 반복**: 전체 인스턴스가 새로운 버전으로 교체될 때까지 이 작업이 반복됩니다.
4. **배포 완료**: 모든 인스턴스가 새로운 버전으로 교체되면 롤링 배포가 완료됩니다.

#### 예시 (Kubernetes Rolling Update):

Kubernetes에서 **롤링 업데이트**는 **Deployment** 리소스를 사용하여 수행됩니다. 새로운 애플리케이션 버전을 배포할 때, 기존 Pod를 하나씩 종료하고 새로운 Pod를 배포하는 방식으로 수행됩니다.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
spec:
  replicas: 4  # 4개의 Pod 실행
  strategy:
    type: RollingUpdate  # 롤링 업데이트 전략 사용
    rollingUpdate:
      maxSurge: 1  # 동시에 추가로 생성되는 Pod 수
      maxUnavailable: 1  # 사용할 수 없는 Pod의 최대 수
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-app-container
        image: my-app:v2  # 새로운 버전의 이미지
```

#### 주요 설정:
- **maxSurge**: 새로운 버전의 인스턴스가 생성될 때, 추가로 몇 개의 인스턴스를 동시에 생성할 수 있는지를 정의합니다.
- **maxUnavailable**: 배포 중에 사용할 수 없는 인스턴스 수를 정의합니다. 이를 통해 서비스 가용성을 제어할 수 있습니다.

---

### 4. **Rolling Deployment의 장점**

- **높은 가용성**: 전체 인스턴스 중 일부만 대체되므로, **서비스 중단이 없거나 매우 짧은 시간 동안만 발생**합니다.
- **점진적 배포**: 배포 중 문제가 발생하면, 배포를 중단하고 일부 인스턴스만 롤백할 수 있어 위험을 줄일 수 있습니다.
- **자원 효율성**: 전체 배포를 진행하는 동안 추가적인 인프라 리소스를 많이 필요로 하지 않으며, **기존 자원**을 효율적으로 사용할 수 있습니다.

---

### 5. **Rolling Deployment의 단점**

- **긴 배포 시간**: 전체 인스턴스를 순차적으로 교체하므로, 대규모 애플리케이션에서는 **배포 시간이 길어질 수 있습니다**.
- **이전 버전과의 호환성 문제**: 새로운 버전과 이전 버전이 동시에 실행되므로, 이들이 서로 호환되지 않을 경우 **데이터 불일치** 또는 **버전 충돌**이 발생할 수 있습니다.
- **즉각적인 롤백이 어려움**: 롤백 과정도 점진적으로 이루어져야 하므로, 문제가 발생했을 때 **즉각적으로 전체 시스템을 롤백**하는 것이 불가능할 수 있습니다.

---

### 6. **Rolling Deployment와 관련된 주요 개념**

- **Canary Deployment**: 롤링 배포와 유사하지만, **전체 배포** 전에 새로운 버전의 일부만 사용자에게 배포하여 안정성을 확인하는 전략입니다.
  
- **Blue-Green Deployment**: 롤링 배포와 다르게, **완전히 별도의 환경**에서 새로운 버전을 배포한 후, 한 번에 트래픽을 전환하는 방식입니다. 이는 롤백이 쉽고 빠르지만 **추가 리소스**가 필요합니다.

---

### 7. **CI/CD에서 Rolling Deployment의 사용**

**CI/CD 파이프라인**에서는 롤링 배포가 **지속적인 배포**와 **무중단 배포**를 위한 중요한 전략입니다. 특히 마이크로서비스 아키텍처와 Kubernetes 환경에서 널리 사용되며, 다음과 같은 단계로 이루어집니다.

1. **지속적 통합**: 새로운 애플리케이션 코드가 **빌드** 및 **테스트** 과정을 거칩니다.
2. **배포 자동화**: CI/CD 파이프라인을 통해 새로운 버전이 점진적으로 배포됩니다.
3. **모니터링**: 배포 과정에서 발생하는 **오류**나 **성능 이슈**를 모니터링하여 즉시 롤백할 수 있습니다.
4. **점진적 롤아웃**: 새로운 버전의 배포가 완료될 때까지 기존 인스턴스를 점진적으로 교체합니다.

---

### 결론

**Rolling Deployment**는 **서비스 가용성을 유지하면서도 지속적으로 애플리케이션을 배포**할 수 있는 강력한 배포 방식입니다. 특히 **Kubernetes**와 같은 **컨테이너 오케스트레이션 플랫폼**에서 자주 사용되며, **CI/CD 파이프라인**에서의 무중단 배포를 실현하는 데 중요한 역할을 합니다. 그러나 롤링 배포는 배포 속도가 느리거나 버전 호환성 문제를 발생시킬 수 있음.

### Blue-Green Deployment: CI에서의 블루-그린 배포 전략

**Blue-Green Deployment**는 **지속적 통합(Continuous Integration, CI)** 및 **지속적 배포(Continuous Delivery, CD)** 환경에서 새로운 애플리케이션 버전을 배포할 때 **무중단 배포**를 보장하는 전략 중 하나입니다. **블루(Blue)** 환경과 **그린(Green)** 환경이라는 두 개의 별도 배포 환경을 활용해, 한쪽에서 실행 중인 애플리케이션을 교체하지 않고 새로운 버전을 다른 환경에서 배포하고, 트래픽을 전환함으로써 배포합니다.

---

### 1. **Blue-Green Deployment의 개념**

**Blue-Green Deployment**는 두 개의 **동일한 환경(Blue와 Green)**을 사용하여 **새로운 애플리케이션 버전**을 안전하게 배포하는 방식입니다. 기존 환경에서 애플리케이션이 계속 실행되는 동안, 새로운 환경에 **새로운 버전의 애플리케이션**을 배포한 후, 모든 트래픽을 **한 번에 전환**하는 방식으로 서비스 중단 없이 배포가 가능합니다.

#### Blue와 Green의 의미:
- **Blue 환경**: 현재 **운영 중인 버전**이 배포된 환경입니다. 기존 애플리케이션 버전이 실행 중이며, 사용자가 이 환경을 통해 서비스를 이용하고 있습니다.
- **Green 환경**: 새로운 애플리케이션 버전이 배포되는 **새로운 환경**입니다. 트래픽이 전환되기 전까지는 사용자가 이 환경에 접근하지 못하며, 새로운 배포에 대한 테스트 및 검증이 진행됩니다.

---

### 2. **Blue-Green Deployment의 주요 특징**

- **완전한 무중단 배포**: Blue 환경에서 기존 애플리케이션이 정상적으로 서비스되고 있는 동안 Green 환경에 새로운 버전을 배포하고, 배포가 완료된 후 트래픽을 **한 번에 전환**하기 때문에 **서비스 중단이 발생하지 않습니다**.
- **빠른 롤백**: 새로운 버전 배포 후 문제가 발생하면, 다시 Blue 환경으로 **트래픽을 신속히 전환**하여 빠르게 롤백할 수 있습니다.
- **격리된 환경**: 배포 중에는 Blue와 Green 환경이 **완전히 격리**되어 있으므로, 새로운 버전의 배포가 기존 서비스에 영향을 주지 않습니다.

---

### 3. **Blue-Green Deployment 과정**

1. **기존 환경(Blue) 실행 중**: Blue 환경에서 현재 애플리케이션 버전이 실행 중이며, 모든 사용자가 이 환경을 통해 서비스를 이용합니다.
2. **새로운 환경(Green)에 배포**: 새로운 버전의 애플리케이션이 Green 환경에 배포되고, 테스트 및 검증을 진행합니다. 트래픽은 여전히 Blue 환경에서 처리됩니다.
3. **트래픽 전환**: Green 환경에서 모든 테스트가 성공적으로 완료되면, **로드 밸런서**나 **DNS 설정**을 통해 모든 트래픽을 Blue에서 Green으로 전환합니다.
4. **검증 후 정리**: 트래픽 전환 후에도 Green 환경에서 문제가 발생하지 않으면, Blue 환경을 제거하거나 다음 배포를 위해 대기 상태로 유지합니다.

#### 예시 (Kubernetes에서의 Blue-Green 배포):

Kubernetes에서 Blue-Green 배포를 구현할 때는, 두 개의 별도 **Deployment** 또는 **서비스**를 설정하고, **Ingress** 또는 **LoadBalancer**를 통해 트래픽을 제어할 수 있습니다.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app-blue
spec:
  replicas: 4
  template:
    metadata:
      labels:
        app: my-app
        version: blue
    spec:
      containers:
      - name: my-app-container
        image: my-app:v1  # 기존 버전
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app-green
spec:
  replicas: 4
  template:
    metadata:
      labels:
        app: my-app
        version: green
    spec:
      containers:
      - name: my-app-container
        image: my-app:v2  # 새로운 버전
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-app-ingress
spec:
  rules:
  - host: my-app.example.com
    http:
      paths:
      - path: /
        backend:
          service:
            name: my-app-green  # 새로운 버전으로 전환
            port:
              number: 80
```

이 설정에서는 **Ingress**를 사용하여 배포 환경 간 트래픽을 제어하고 있습니다. 배포 후, `Ingress` 설정을 변경하여 트래픽을 Green 버전으로 전환할 수 있습니다.

---

### 4. **Blue-Green Deployment의 장점**

- **완전한 무중단 배포**: 트래픽을 기존 환경에서 새로운 환경으로 한 번에 전환하므로 서비스 중단 없이 배포가 가능합니다.
- **빠른 롤백**: 새로운 버전에서 문제가 발생하면 **즉시 Blue 환경으로 롤백**할 수 있어, 복구가 매우 빠릅니다.
- **배포 테스트와 검증 용이**: Green 환경에서 모든 배포와 테스트가 이루어지므로, 운영 중인 시스템에 영향을 주지 않고 안정적으로 배포를 진행할 수 있습니다.
- **리소스 격리**: Blue와 Green 환경이 물리적 또는 논리적으로 완전히 분리되어 있어 **배포 중 리소스 충돌**이 발생하지 않습니다.

---

### 5. **Blue-Green Deployment의 단점**

- **자원 소모**: 두 개의 별도 환경(Blue와 Green)을 유지해야 하므로, 배포 시점에 **추가적인 인프라 리소스**가 필요합니다. 특히, 대규모 서비스에서는 자원 사용량이 크게 증가할 수 있습니다.
- **데이터 일관성**: 데이터베이스 변경이나 마이그레이션이 필요한 경우, **데이터 일관성** 문제가 발생할 수 있습니다. 이 경우, **데이터 동기화** 전략이 추가로 필요합니다.
- **트래픽 전환 리스크**: 트래픽을 한 번에 전환하는 방식이기 때문에, 전환 중 문제가 발생하면 **전체 서비스**에 영향을 미칠 수 있습니다.

---

### 6. **Blue-Green Deployment와 관련된 주요 개념**

- **Canary Deployment**: 새로운 버전을 **소규모 트래픽**에 먼저 배포하여 테스트하고, 점차 전체 트래픽으로 확장하는 배포 전략입니다. 이는 Blue-Green 배포와 달리 **점진적 배포**를 통해 위험을 최소화합니다.
  
- **Shadow Deployment**: 새로운 버전을 **실제 트래픽**과 동일한 트래픽으로 테스트하지만, **응답을 실제로 반환하지 않는** 배포 방식입니다. 이를 통해 실시간 트래픽 기반 성능 테스트가 가능합니다.

---

### 7. **CI/CD에서 Blue-Green Deployment의 사용**

Blue-Green 배포는 CI/CD 파이프라인에서 **완전한 무중단 배포**와 **안정성 보장**을 위한 중요한 배포 전략입니다. 다음과 같은 단계로 이루어집니다.

1. **지속적 통합(CI)**: 새로운 애플리케이션 버전이 빌드 및 테스트 과정을 거칩니다.
2. **Green 환경에 배포**: 새로운 버전이 Green 환경에 배포되며, 배포 후 안정성 테스트가 진행됩니다.
3. **트래픽 전환**: 배포 및 테스트가 완료되면, 모든 트래픽을 **한 번에 Green 환경으로 전환**합니다.
4. **모니터링 및 검증**: Green 환경으로 전환된 후, 트래픽이 정상적으로 처리되는지 모니터링합니다.
5. **Blue 환경 종료 또는 대기**: 배포가 성공적이면 Blue 환경을 제거하거나, 다음 배포를 위해 대기 상태로 유지합니다.

---

### 결론

**Blue-Green Deployment**는 **지속적 배포(CD)** 환경에서 **서비스 중단 없이 애플리케이션을 배포**할 수 있는 강력한 전략입니다. 특히 트래픽 전환을 통해 신속하게 배포하고, 문제 발생 시 빠른 롤백을 지원하여 **안정성과 유연성**을 모두 제공합니다. 그러나 두 환경을 동시에 유지해야 하는 리소스 부담이 있으며, 데이터베이스 마이그레이션이 포함된 경우에는 별도의 일관성 관리가 필요할 수 있습니다.

**Kubernetes**, **AWS** 등 클라우드 환경에서 Blue-Green 배포 전략을 통해 **대규모 애플리케이션의 무중단 배포**를 효율적으로 구현할 수 있습니다.

### Canary Deployment: CI에서의 카나리 배포 전략

**Canary Deployment**는 **지속적 통합(Continuous Integration, CI)** 및 **지속적 배포(Continuous Delivery, CD)** 환경에서 새로운 애플리케이션 버전을 **소규모 트래픽**에 먼저 배포한 후, 점진적으로 전체 트래픽으로 확장하는 방식의 배포 전략입니다. 이를 통해 **새로운 버전의 안정성을 검증**한 후에야 전체 시스템에 영향을 미치므로, 배포 리스크를 줄일 수 있습니다.

---

### 1. **Canary Deployment의 개념**

**Canary Deployment**는 새로운 애플리케이션 버전을 **전체 사용자에게 한 번에 배포하지 않고**, 일부 트래픽에만 배포한 후 점진적으로 확장하는 배포 전략입니다. 이 방식은 새로운 버전이 문제 없이 작동하는지 소규모로 테스트하고, 이상이 없을 때 전체 트래픽으로 확장할 수 있습니다.

#### Canary 배포의 흐름:
1. **소규모 배포**: 새로운 애플리케이션 버전이 먼저 **소규모 사용자 그룹**에게 배포됩니다.
2. **성능 및 오류 모니터링**: 소규모 트래픽에서 배포된 버전의 **성능**, **오류** 및 **사용자 피드백**을 모니터링합니다.
3. **점진적 확장**: 문제가 발생하지 않으면, 점진적으로 더 많은 트래픽을 새로운 버전으로 라우팅합니다.
4. **전체 배포 완료**: 최종적으로 모든 트래픽이 새로운 버전으로 전환되면, 배포가 완료됩니다.

---

### 2. **Canary Deployment의 주요 특징**

- **안정성 검증**: 새로운 버전이 문제가 없는지 **소규모 사용자**를 대상으로 먼저 검증할 수 있습니다.
- **리스크 최소화**: 전체 시스템에 미치는 영향을 최소화하며, **점진적 배포**로 인해 문제가 발생해도 빠르게 대응할 수 있습니다.
- **빠른 롤백 가능**: 문제 발생 시, **카나리 배포된 인스턴스만 롤백**하면 되므로, 전체 시스템에 미치는 영향을 최소화할 수 있습니다.
- **유연한 트래픽 제어**: 배포 중 트래픽을 유동적으로 관리할 수 있으며, 트래픽 비율을 점진적으로 조정할 수 있습니다.

---

### 3. **Canary Deployment 과정**

1. **현재 애플리케이션 실행 중**: 기존 버전의 애플리케이션이 전체 트래픽을 처리하고 있습니다.
2. **카나리 버전 배포**: 새로운 애플리케이션 버전이 **일부 인스턴스** 또는 **소수의 사용자**에게 배포됩니다. 이때 전체 트래픽 중 **소량의 트래픽**만 새로운 버전으로 라우팅됩니다.
3. **모니터링 및 검증**: 새로운 버전에서 성능이나 오류가 없는지 **성능 지표**와 **로그**를 통해 모니터링합니다.
4. **점진적 트래픽 확장**: 문제가 없다면 점차 더 많은 트래픽을 새로운 버전으로 라우팅합니다.
5. **전체 배포 완료**: 모든 트래픽이 새로운 버전으로 전환되면 배포가 완료됩니다.
6. **롤백(선택적)**: 배포 중 문제가 발생하면, 카나리로 배포된 부분만 롤백할 수 있습니다.

#### 예시 (Kubernetes에서의 Canary 배포):

Kubernetes에서는 **카나리 배포**를 통해 트래픽의 일부만 새로운 버전으로 라우팅하는 방식으로 배포를 수행할 수 있습니다. 이를 위해, **Deployment** 리소스를 나누거나, **Service**와 **Ingress**를 활용해 트래픽을 분산할 수 있습니다.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app-stable
spec:
  replicas: 3
  template:
    metadata:
      labels:
        app: my-app
        version: stable
    spec:
      containers:
      - name: my-app-container
        image: my-app:v1  # 기존 버전
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app-canary
spec:
  replicas: 1  # 카나리 배포는 1개의 인스턴스만 배포
  template:
    metadata:
      labels:
        app: my-app
        version: canary
    spec:
      containers:
      - name: my-app-container
        image: my-app:v2  # 새로운 버전
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-app-ingress
spec:
  rules:
  - host: my-app.example.com
    http:
      paths:
      - path: /
        backend:
          service:
            name: my-app-stable  # 기본적으로 기존 버전으로 라우팅
            port:
              number: 80
          weight: 80  # 트래픽의 80%를 기존 버전으로
      - path: /
        backend:
          service:
            name: my-app-canary  # 카나리 버전으로 라우팅
            port:
              number: 80
          weight: 20  # 트래픽의 20%만 새로운 버전으로
```

이 설정에서는 **트래픽의 80%**가 기존 버전(Stable)으로 라우팅되고, **20%**가 카나리 버전으로 라우팅됩니다. 문제가 발생하지 않으면 점차 새로운 버전으로 트래픽을 늘려갈 수 있습니다.

---

### 4. **Canary Deployment의 장점**

- **리스크 완화**: 전체 트래픽을 한 번에 새로운 버전으로 전환하지 않으므로, **배포 리스크가 줄어듭니다**.
- **빠른 롤백**: 문제가 발생하면 **카나리 배포된 인스턴스**만 롤백할 수 있으므로, 전체 배포를 롤백할 필요가 없습니다.
- **사용자 피드백 반영**: 소규모 사용자 그룹에서 새로운 기능에 대한 **피드백**을 받고 이를 기반으로 최종 버전 배포 전 수정할 수 있습니다.
- **점진적 확장**: 배포 후에도 트래픽을 점진적으로 증가시킬 수 있어 **안정적인 확장**이 가능합니다.

---

### 5. **Canary Deployment의 단점**

- **복잡한 모니터링 필요**: 배포 중에 소규모 사용자 트래픽을 기반으로 **모니터링**해야 하므로, **정교한 성능 모니터링 도구**가 필요합니다.
- **데이터 일관성 문제**: 데이터베이스와 연동된 경우, 새로운 버전과 기존 버전 간의 **데이터 불일치**가 발생할 수 있으며, 이를 해결하기 위한 별도의 동기화 작업이 필요합니다.
- **시간이 오래 걸릴 수 있음**: 트래픽을 점진적으로 증가시키기 때문에, 전체 배포 완료까지 시간이 오래 걸릴 수 있습니다.

---

### 6. **Canary Deployment와 관련된 주요 개념**

- **A/B Testing**: Canary 배포와 비슷하게 소규모 사용자 그룹에 새로운 기능을 배포하고, 이를 통해 **두 가지 버전의 성능을 비교**하는 방식입니다. 다만, A/B 테스트는 **사용자 행동 분석**에 더 중점을 둡니다.
  
- **Feature Toggle**: 새로운 기능을 배포하되, **기능을 제어하는 토글**을 설정하여 필요에 따라 기능을 활성화하거나 비활성화할 수 있는 전략입니다. 이를 통해 Canary 배포와 함께 **기능 단위의 점진적 활성화**가 가능합니다.

---

### 7. **CI/CD에서 Canary Deployment의 사용**

Canary 배포는 **CI/CD 파이프라인**에서 **점진적 배포**와 **무중단 배포**를 위해 자주 사용되는 전략입니다. 다음과 같은 단계로 진행됩니다:

1. **지속적 통합(CI)**: 새로운 애플리케이션 버전이 빌드되고, 테스트가 완료됩니다.
2. **카나리 배포**: 새로운 버전이 **일부 사용자** 또는 **일부 인스턴스**에만 배포됩니다.
3. **모니터링**: 소규모 트래픽을 대상으로 **성능 모니터링**을 수행하여 오류가 발생하는지 확인합니다.
4. **트래픽 확장**: 문제가 없으면 트래픽을 점진적으로 새로운 버전으로 확장해 나갑니다.
5. **롤백 또는 전체 배포**: 문제가 발생하면 카나리 배포된 인스턴스만 롤백하고, 문제가 없다면 전체 시스템에 새로운 버전을 배포합니다.

---

### 결론

**Canary Deployment**는 새로운 버전의 애플리케이션을 **안전하게 배포**할 수 있는 매우 유용한 전략으로, 전체 시스템에 영향을 주지 않고 **소규모 트래픽에서 먼저 검증**
